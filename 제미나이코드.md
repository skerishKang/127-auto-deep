RPA/업무 자동화 엔지니어 및 교재 집필자로서 요청하신 "다양한 자동화 예시와 시나리오 (코드 vs n8n 비교)" 리서치 결과를 정리했습니다. 총 25개의 시나리오를 난이도별로 분류하고, 실무 활용 방안을 포함했습니다.

-----

### [입문] (Intro)

단순하고 선형적인 작업, 즉각적인 피드백을 받을 수 있는 시나리오.

────────────────────────────
[입문] 시나리오 1️⃣: **메일 첨부파일 자동 다운로드 및 정리**

  - **코드 구현**: Python (imaplib, os, email)
  - **주요 단계**: (트리거) 특정 메일 서버 접속/폴링 → (로직) 제목/발신인 필터링 → (로직) 첨부파일 추출 → (출력) 날짜별 폴더 생성 및 저장
  - **n8n 구성**: Gmail / IMAP Trigger → IF Node (조건 필터) → Move Binary Data (파일 저장) → (Optional) Google Sheets (로그)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `imaplib` + `schedule` (주기적 폴링) | Gmail Trigger / IMAP Trigger |
    | 조건 필터 | `if "세금계산서" in email.subject:` | IF Node (Subject contains "세금계산서") |
    | 파일 처리 | `os.path.join`, `open(..., 'wb')` | Move Binary Data (Rename/Move) |
    | 로그 | `logging` 라이브러리 | Google Sheets (Append Row) |
  - **실무 활용**:
      - **적용 부서**: 재무팀, 영업관리팀
      - **도입 효과**: 일일/월간 세금계산서, 계약서 등 수동 다운로드 및 정리 작업 '0'화.
      - **확장 아이디어**: 다운로드된 파일명 규칙(e.g., `YYYY-MM-DD_거래처명.pdf`) 자동 변경.

────────────────────────────
[입문] 시나리오 2️⃣: **매일 아침 정기 브리핑 (날씨/환율)**

  - **코드 구현**: Python (requests, beautifulsoup4, smtplib)
  - **주요 단계**: (트리거) 매일 오전 8시 스케줄 실행 → (로직) 네이버 날씨/환율 크롤링 → (로직) 메시지 포맷팅 → (출력) 슬랙/메일 발송
  - **n8n 구성**: Cron (Schedule) → HTTP Request (크롤링) → HTML Extract → Set Node (데이터 가공) → Slack / Send Email
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `schedule` 라이브러리, Crontab | Cron Node |
    | 크롤링 | `requests.get()` + `BeautifulSoup` | HTTP Request + HTML Extract |
    | 데이터 가공 | `f"오늘 날씨: {temp}도"` | Set Node (Expression 사용) |
    | 알림 | `smtplib` (메일) or `requests.post` (슬랙) | Slack Node / Send Email Node |
  - **실무 활용**:
      - **적용 부서**: 전사 (공용 채널)
      - **도입 효과**: 매일 반복되는 정보 검색 시간을 절약하고 팀 전체에 정보 공유.
      - **확장 아이디어**: 회사 공지사항, 주요 KOSPI 지수 등 정보 추가.

────────────────────────────
[입문] 시나리오 3️⃣: **특정 키워드 포함 메일 수신 시 슬랙 알림**

  - **코드 구현**: Python (imaplib, requests)
  - **주요 단계**: (트리거) 메일 서버 실시간(혹은 1분 주기) 폴링 → (로직) "장애", "긴급", "클레임" 키워드 포함 여부 확인 → (출력) 즉시 슬랙으로 알림
  - **n8n 구성**: Gmail / IMAP Trigger → IF Node (필터) → Slack Node
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `imaplib.search()` (무한 루프 폴링) | Gmail Trigger (Push) |
    | 키워드 필터 | `if '장애' in subject or '긴급' in body:` | IF Node (Regex 또는 Contains) |
    | 알림 | `requests.post(slack_webhook_url, ...)` | Slack Node |
  - **실무 활용**:
      - **적용 부서**: CS팀, IT 운영팀
      - **도입 효과**: 중요 장애 및 고객 클레임에 대한 대응 시간(Response Time) 획기적 단축.
      - **확장 아이디어**: 키워드별로 담당자가 다른 채널로 알림을 분기.

────────────────────────────
[입문] 시나리오 4️⃣: **RSS 피드 구독 및 팀 채널 공유**

  - **코드 구현**: Python (feedparser, requests)
  - **주요 단계**: (트리거) 1시간 주기 스케줄 실행 → (로직) 구독할 RSS 피드 목록 순회 → (로직) 마지막 확인 시간 이후 신규 항목 필터링 → (출력) 슬랙 채널에 공유
  - **n8n 구성**: RSS Feed Trigger → (Optional) IF (새 항목인지 확인) → Slack Node
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `schedule` + `feedparser.parse()` | RSS Feed Trigger |
    | 새 항목 필터 | 마지막 게시물 시간/ID 저장 및 비교 | Trigger가 자체적으로 새 항목만 전달 |
    | 알림 | `requests.post(slack_webhook_url, ...)` | Slack Node |
  - **실무 활용**:
      - **적용 부서**: 마케팅팀, 개발팀
      - **도입 효과**: 경쟁사 동향, 기술 트렌드, 신규 블로그 포스트 등을 누락 없이 실시간으로 공유.
      - **확장 아이디어**: 특정 키워드(e.g., 'AI', 'n8n')가 포함된 피드만 별도 채널로 알림.

────────────────────────────
[입문] 시나리오 5️⃣: **로컬 폴더 자동 백업**

  - **코드 구현**: Python (os, shutil, schedule)
  - **주요 단계**: (트리거) 매일 자정 스케줄 실행 → (로직) `A` 폴더의 모든 파일/하위 폴더 복사 → (출력) `B` 백업 폴더(e.g., NAS)에 덮어쓰기
  - **n8n 구성**: Cron → Execute Command (OS 명령어 실행)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `schedule` 라이브러리 | Cron Node |
    | 파일 복사 | `shutil.copytree(src, dst)` | Execute Command (`cp -r src dst`) |
    | 실행 환경 | Python 스크립트 실행 환경 | n8n이 설치된 서버 환경 |
  - **실무 활용**:
      - **적용 부서**: 디자인팀, 개인 (중요 작업 파일)
      - **도입 효과**: 로컬 PC의 중요 작업물을 네트워크 드라이브나 백업 서버로 자동 백업하여 유실 방지.
      - **확장 아이디어**: 단순 복사가 아닌 `rsync` 명령어를 사용하여 변경된 파일만 증분 백업.

-----

### [기초] (Basic)

간단한 조건 분기(IF)가 포함되거나, 두 개 이상의 서비스를 연동하는 시나리오.

────────────────────────────
[기초] 시나리오 6️⃣: **구글 폼 제출 시 담당자에게 알림 및 시트 자동 정리**

  - **코드 구현**: Google Apps Script (JavaScript)
  - **주요 단계**: (트리거) 구글 폼 `onFormSubmit` → (로직) 제출된 응답 데이터 확보 → (로직) 응답 내용에 따라 담당자 지정 (e.g., '문의유형'이 'A'이면 '김팀장') → (출력) 담당자에게 메일 발송, 응답 시트에 '담당자' 열 자동 업데이트
  - **n8n 구성**: Google Form Trigger → IF Node (분기) → Set Node (담당자 할당) → Google Sheets (업데이트) + Send Email (알림)
  - **비교표**:
    | 항목 | 코드 (Google Apps Script) | n8n |
    |---|---|---|
    | 트리거 | `onFormSubmit` 이벤트 트리거 | Google Form Trigger (Webhook) |
    | 조건 분기 | `if (e.values[2] == 'A') { ... }` | IF Node (문의유형) |
    | 시트 업데이트 | `sheet.getRange(row, col).setValue(manager)` | Google Sheets Node (Update) |
    | 알림 | `MailApp.sendEmail(email, ...)` | Send Email Node / Slack Node |
  - **실무 활용**:
      - **적용 부서**: HR팀 (휴가 신청), 영업팀 (B2B 문의)
      - **도입 효과**: 폼 제출 즉시 담당자에게 연결되어 리드타임 감소, 수동 배정 실수 방지.
      - **확장 아이디어**: 담당자 배정을 라운드 로빈(Round Robin) 방식으로 순환 배정.

────────────────────────────
[기초] 시나리오 7️⃣: **웹사이트 장애 모니터링**

  - **코드 구현**: Python (requests, schedule, smtplib)
  - **주요 단계**: (트리거) 5분 주기 스케줄 실행 → (로직) 모니터링할 URL 목록 순회 → (로직) `requests.get()` 호출 및 HTTP 상태 코드 확인 → (로직) 상태 코드가 200이 아니거나 응답 시간이 5초 이상일 경우 → (출력) 즉시 담당자에게 알림
  - **n8n 구성**: Cron (Interval) → HTTP Request (URL 체크) → IF Node (조건: Status Code \!= 200) → Slack / Email
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `schedule.every(5).minutes.do(job)` | Cron Node (Every 5 Minutes) |
    | 상태 체크 | `response = requests.get(url, timeout=5)`<br>`if response.status_code != 200:` | HTTP Request (Error on Fail: False) → IF |
    | 알림 | `smtplib.SMTP(...).sendmail(...)` | Slack Node (장애 채널) |
  - **실무 활용**:
      - **적용 부서**: IT 인프라팀, 서비스 개발팀
      - **도입 효과**: 유료 모니터링 솔루션 없이 핵심 서비스의 가용성(Uptime)을 실시간으로 확인.
      - **확장 아이디어**: 장애 복구 시 (상태 코드 200으로 복귀) "복구 알림" 자동 발송.

────────────────────────────
[기초] 시나리오 8️⃣: **엑셀(CSV) 파일 구글 시트로 자동 임포트**

  - **코드 구현**: Python (pandas, gspread, openpyxl)
  - **주요 단계**: (트리거) 특정 폴더에 `.xlsx` 또는 `.csv` 파일이 감지되면 (혹은 스케줄) → (로직) `pandas`로 엑셀 파일 읽기 → (로직) 데이터프레임을 리스트로 변환 → (출력) `gspread` 라이브러리로 구글 시트 특정 탭에 데이터 덮어쓰기
  - **n8n 구성**: (Trigger: e.g., Cron) → Read Binary File (로컬) → Spreadsheet File (엑셀 읽기) → Google Sheets (Append/Update)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `schedule` 또는 `watchdog` (파일 감지) | Cron / Webhook (파일 업로드 시) |
    | 엑셀 읽기 | `pd.read_excel(file_path)` | Spreadsheet File Node |
    | 시트 쓰기 | `gspread.service_account(...)`<br>`worksheet.update(...)` | Google Sheets Node (Append/Update) |
  - **실무 활용**:
      - **적용 부서**: 데이터 분석팀, 마케팅팀
      - **도입 효과**: 매일 ERP 등에서 다운로드하는 엑셀 데이터를 구글 시트 기반 대시보드에 자동 반영.
      - **확장 아이디어**: 임포트 완료 후 원본 엑셀 파일을 '완료' 폴더로 이동.

────────────────────────────
[기초] 시나리오 9️⃣: **특정 키워드 메일 수신 시 구글 캘린더 자동 등록**

  - **코드 구현**: Google Apps Script (JavaScript)
  - **주요 단계**: (트리거) Gmail 받은편지함 1분 주기 스캔 → (로직) 제목에 "[미팅]" 또는 "[일정]" 키워드가 있고, 아직 처리되지 않은 메일 필터링 → (로직) 메일 본문에서 날짜, 시간, 참석자 파싱 (정규식) → (출력) 구글 캘린더에 이벤트 생성 및 메일에 '처리완료' 라벨 부착
  - **n8n 구성**: Gmail Trigger (필터: `[미팅]`) → Set Node (날짜/시간 파싱, Regex) → Google Calendar Node
  - **비교표**:
    | 항목 | 코드 (Apps Script) | n8n |
    |---|---|---|
    | 트리거 | `GmailApp.search(...)` (Time-driven) | Gmail Trigger (Filter) |
    | 본문 파싱 | `body.match(/(\d{4}년 \d{1,2}월 ...)/)` | Set Node (Expression, Regex) |
    | 캘린더 생성 | `CalendarApp.createEvent(...)` | Google Calendar Node (Create) |
  - **실무 활용**:
      - **적용 부서**: 영업 대표, 임원 비서팀
      - **도입 효과**: 외부에서 수신되는 미팅 요청 메일을 누락 없이 캘린더에 자동 반영.
      - **확장 아이디어**: 본문 파싱이 어려운 경우, 수신자에게 '일정 등록 폼' 링크가 포함된 답장 자동 발송.

────────────────────────────
[기초] 시나리오 10️⃣: **슬랙 특정 채널 메시지 -\> 노션 데이터베이스 백업**

  - **코드 구현**: Python (slack\_sdk, notion\_client, schedule)
  - **주요 단계**: (트리거) 1시간 주기 스케줄 실행 → (로직) 슬랙 `conversations.history` API로 특정 채널 메시지 조회 → (로직) 마지막 백업 시간 이후 메시지만 필터링 → (출력) `notion_client`로 노션 DB에 페이지 생성 (작성자, 시간, 내용)
  - **n8n 구성**: Slack Trigger (New Message) → Notion Node (Create Page)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `schedule` + `slack_sdk` (Polling) | Slack Trigger (Webhook - Realtime) |
    | 데이터 추출 | `client.conversations_history(channel=...)` | Trigger가 데이터($json) 자동 전달 |
    | 노션 저장 | `notion.pages.create(parent=...)` | Notion Node (Create) |
  - **실무 활용**:
      - **적용 부서**: 고객 지원팀, 아이디어 채널
      - **도입 효과**: 휘발성 높은 슬랙 대화 중 중요한 내용(고객 피드백, 아이디어)을 영구적인 DB(노션)에 자동 아카이빙.
      - **확장 아이디어**: 특정 이모지(e.g., :idea:)가 달린 메시지만 노션에 저장.

-----

### [중급] (Intermediate)

데이터 변형(Transformation)이 필요하거나, 여러 단계의 API 연동, 복잡한 분기 처리가 포함된 시나리오.

────────────────────────────
[중급] 시나리오 11️⃣: **주간 업무 보고서 데이터 취합 및 Notion/Confluence 발행**

  - **코드 구현**: Python (gspread, requests, openpyxl, notion\_client)
  - **주요 단계**: (트리거) 매주 금요일 오후 3시 스케줄 실행 → (로직) 여러 팀의 구글 시트/엑셀 파일에서 실적 데이터 취합 → (로직) 데이터 요약/집계 (e.g., Pandas) → (로직) 보고서 템플릿(Markdown/HTML)에 데이터 삽입 → (출력) Notion / Confluence API로 주간 보고서 페이지 생성
  - **n8n 구성**: Cron → Google Sheets (Read) x 3 → Merge Node (데이터 병합) → Code Node (데이터 집계/가공) → Notion / Confluence Node
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | Crontab (Linux) | Cron Node |
    | 데이터 취합 | `gspread` (GSheet) + `openpyxl` (Excel) | Google Sheets Node, Read Binary File |
    | 데이터 집계 | `pandas.DataFrame.groupby().sum()` | Code Node (JS/Python) or Function Node |
    | 문서 발행 | `notion_client.pages.create(...)` | Notion Node (Append Block / Create Page) |
  - **실무 활용**:
      - **적용 부서**: 프로젝트 관리(PMO), 기획팀
      - **도입 효과**: 수동으로 취합하던 주간 보고서 작성 시간을 1\~2시간/주 단축.
      - **확장 아이디어**: 보고서 발행 후 경영진 채널에 요약 및 링크 자동 알림.

────────────────────────────
[중급] 시나리오 12️⃣: **고객 문의(CS) 자동 분류 및 Jira/Trello 티켓 생성**

  - **코드 구현**: Python (imaplib, requests, re)
  - **주요 단계**: (트리거) CS 대표 메일 수신 → (로직) 본문 내용 키워드 분석 (e.g., '환불', '배송', '오류') → (로직) IF-ELSE 분기 (환불/배송 -\> CS팀 Trello, 오류 -\> 개발팀 Jira) → (출력) Trello/Jira API 호출하여 카드/이슈 생성
  - **n8n 구성**: Gmail Trigger → Switch Node (키워드 분기) → [Route 1] Trello Node → [Route 2] Jira Node
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `imaplib` 폴링 | Gmail Trigger |
    | 분류 | `if '환불' in body: ... elif '오류' in body:` | Switch Node (Property: `body`) |
    | 티켓 생성 1 | `requests.post(trello_api_url, ...)` | Trello Node |
    | 티켓 생성 2 | `jira.create_issue(project=...)` | Jira Node |
  - **실무 활용**:
      - **적용 부서**: 고객지원팀, 개발팀
      - **도입 효과**: CS 문의 누락 방지 및 담당 팀(개발/운영)으로의 신속한 이관.
      - **확장 아이디어**: (AI 응용) 단순 키워드가 아닌 LLM을 이용한 감성 분석 및 의도 파악.

────────────────────────────
[중급] 시나리오 13️⃣: **신규 입사자 온보딩 프로세스 자동화**

  - **코드 구현**: Python/JS (gspread, smtplib, requests)
  - **주요 단계**: (트리거) HR팀의 '신규입사자 명단' 구글 시트에 새 행 추가 → (로직) IT팀에 '계정 생성' 요청 메일 발송 → (로직) 업무지원팀에 '장비 세팅' 요청 Jira 티켓 생성 → (로직) 신규 입사자에게 '웰컴 폼' 링크 메일 발송
  - **n8n 구성**: Google Sheets Trigger (New Row) → Split in Batches → Send Email (IT팀) + Jira Node (업무지원팀) + Send Email (입사자)
  - **비교표**:
    | 항목 | 코드 (Google Apps Script) | n8n |
    |---|---|---|
    | 트리거 | `onEdit` 또는 `onChange` 트리거 (시트) | Google Sheets Trigger (On Row Added) |
    | 병렬 처리 | 순차적 실행 (코드 복잡도 증가) | 노드가 자동으로 병렬/순차 실행 (3개 분기) |
    | 계정 요청 | `MailApp.sendEmail('it@...)` | Send Email Node |
    | 장비 요청 | `requests.post(jira_api, ...)` | Jira Node |
  - **실무 활용**:
      - **적용 부서**: HR팀, IT팀, 업무지원팀
      - **도입 효과**: 신규 입사자 온보딩 누락(계정, 장비) 방지 및 입사 첫날 경험(DX) 향상.
      - **확장 아이디어**: 입사 1주 후, 1달 후 자동 팔로업 설문조사 메일 발송.

────────────────────────────
[중급] 시나리오 14️⃣: **일일 매출 DB 집계 및 차트 이미지 생성/보고**

  - **코드 구현**: Python (mysql-connector, pandas, matplotlib, smtplib)
  - **주요 단계**: (트리거) 매일 자정 스케줄 실행 → (로직) 운영 DB 접속 및 어제 매출 데이터 쿼리 → (로직) `pandas`로 데이터 집계 (e.g., 상품별, 시간대별) → (로직) `matplotlib`으로 꺾은선/바 차트 생성 및 이미지 파일로 저장 → (출력) 차트 이미지를 첨부하여 경영진에게 일일 보고 메일 발송
  - **n8n 구성**: Cron → MySQL Node (쿼리) → Code Node (데이터 집계/차트 생성 - `matplotlib` 필요) → Send Email (첨부파일)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | DB 쿼리 | `mysql.connector.connect()`<br>`cursor.execute(sql)` | MySQL Node |
    | 데이터 집계 | `df.groupby('product').sum()` | Code Node (JS/Python) |
    | 차트 생성 | `matplotlib.pyplot.save_fig('chart.png')` | Code Node (Python) + `matplotlib` <br> (n8n 환경에 라이브러리 설치 필요) |
    | 메일 발송 | `MIMEMultipart` + `MIMEImage` | Send Email Node (Attachments) |
  - **실무 활용**:
      - **적용 부서**: 경영진, 데이터 분석팀
      - **도입 효과**: 매일 아침 수동으로 뽑던 매출 리포트를 자동화하고 시각화 자료로 제공.
      - **확장 아이디어**: n8n의 Code Node 대신 차트 생성 API (e.g., QuickChart) 사용 (설치 의존성 제거).

────────────────────────────
[중급] 시나리오 15️⃣: **경쟁사 신규 키워드/콘텐츠 모니터링**

  - **코드 구현**: Python (requests, beautifulsoup4, difflib, schedule)
  - **주요 단계**: (트리거) 1시간 주기 스케줄 실행 → (로직) 경쟁사 사이트 목록 크롤링 → (로직) 이전 크롤링 결과(HTML)와 현재 결과 비교 (`difflib`) → (로직) 변경 사항(신규 상품, 신규 포스트) 발생 시 → (출력) 변경된 부분만 캡처하여 슬랙 알림
  - **n8n 구성**: Cron → HTTP Request (Loop) → Merge Node (이전 데이터와 비교) → IF Node (변경 감지) → Slack Node
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `schedule` 라이브러리 | Cron Node |
    | 상태 저장/비교 | `db` 또는 `file`에 이전 HTML 저장<br>`difflib.HtmlDiff().make_file(...)` | 'Static Data' 저장 또는<br>Merge Node (이전 실행과 Join) |
    | 변경 알림 | `requests.post(slack_webhook_url, ...)` | Slack Node |
  - **실무 활용**:
      - **적용 부서**: 마케팅팀, 전략기획팀
      - **도입 효과**: 경쟁사의 가격 변동, 신규 서비스 출시, 이벤트 시작 등을 가장 빠르게 감지.
      - **확장 아이디어**: 단순 HTML 비교가 아닌, 특정 CSS 선택자(e.g., `product-list`) 내부의 항목 수 비교.

-----

### [고급] (Advanced)

여러 시스템 간의 복잡한 데이터 동기화, 에러 핸들링, 조건부 승인 로직 등 고난도 시나리오.

────────────────────────────
[고급] 시나리오 16️⃣: **영업 리드(Lead) 자동화 (웹사이트 폼 → CRM → 담당자 배정)**

  - **코드 구현**: JS (Node.js/Express) + Python (Salesforce/Hubspot API)
  - **주요 단계**: (트리거) 웹사이트 폼 제출 시 Webhook 수신 → (로직) 데이터 유효성 검사 → (로직) Salesforce/Hubspot API로 리드(Lead) 생성 → (로직) 리드 등급/지역에 따라 담당자 자동 배정 (라운드 로빈) → (출력) 담당자에게 슬랙 알림 ("신규 리드 할당\!")
  - **n8n 구성**: Webhook Trigger → Salesforce / Hubspot Node (Create Lead) → Switch Node (등급/지역) → Set Node (담당자 배정 로직) → Slack Node (DM)
  - **비교표**:
    | 항목 | 코드 (Python/JS) | n8n |
    |---|---|---|
    | 트리거 | `app.post('/webhook', ...)` (Express) | Webhook Node |
    | CRM 연동 | `salesforce-simple` 라이브러리 | Salesforce / Hubspot Node |
    | 담당자 배정 | `round_robin_index = (index + 1) % len(list)` | Code Node or Set (Expression) |
    | 알림 | `slack_sdk.chat_postMessage(channel=user_id)` | Slack Node (DM to User ID) |
  - **실무 활용**:
      - **적용 부서**: 영업팀, 마케팅팀
      - **도입 효과**: 잠재 고객 문의에 대한 응답 속도를 '분' 단위로 단축하여 영업 기회(CVR) 극대화.
      - **확장 아이디어**: 리드 생성 후 24시간 내 담당자 연락 없을 시, 매니저에게 자동 에스컬레이션 알림.

────────────────────────────
[고급] 시나리오 17️⃣: **인보이스(세금계산서) PDF → OCR → ERP 데이터 입력**

  - **코드 구현**: Python (imaplib, pdfplumber, Google Vision AI/Tesseract, requests)
  - **주요 단계**: (트리거) 메일 수신 (첨부파일 PDF) → (로직) PDF 파일 다운로드 → (로직) OCR API (e.g., Google Vision) 호출하여 텍스트 추출 → (로직) 정규식(Regex)으로 공급자, 금액, 날짜, 품목 파싱 → (출력) ERP/회계 시스템 API로 데이터 전송 or 구글 시트 기록
  - **n8n 구성**: Gmail Trigger (Has Attachment) → Move Binary Data → Google Vision Node (OCR) / Tesseract (OCR) → Code Node (Regex 파싱) → Google Sheets / HTTP Request (ERP)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | PDF 텍스트화 | `google.cloud.vision` 또는 `pytesseract` | Google Vision Node / Tesseract Node |
    | 데이터 파싱 | `re.search(r"총액: (\d+)", text)` | Code Node (JS/Python Regex) |
    | ERP 전송 | `requests.post(erp_api_endpoint, ...)` | HTTP Request Node (POST) |
  - **실무 활용**:
      - **적용 부서**: 재무팀, 회계팀
      - **도입 효과**: 매월 수십\~수백 건의 거래처 인보이스(계산서) 수동 입력 작업을 자동화.
      - **확장 아이디어**: 파싱된 금액과 발주서(PO) 금액이 일치하는지 자동 검증 로직 추가.

────────────────────────────
[고급] 시나리오 18️⃣: **서버 로그 분석 및 이상 감지(Anomaly Detection) 알림**

  - **코드 구현**: Python (watchdog, re, pandas)
  - **주요 단계**: (트리거) S3/로컬 로그 파일 `append` 감지 → (로직) 실시간으로 로그 라인 읽기 → (로직) `FATAL`, `ERROR` 등 특정 패턴 정규식(Regex)으로 감지 → (로직) 5분 내 동일 에러 10회 이상 발생 시 (집계) → (출력) Jira 이슈 생성 및 PagerDuty/Slack 즉시 알림
  - **n8n 구성**: AWS S3 Trigger (New File) / Cron (Read File) → Read Binary File → Split in Batches (라인별) → IF (Regex) → Code Node (에러 카운팅/집계) → IF (10회 이상) → Jira / PagerDuty / Slack
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `watchdog` (파일 시스템 이벤트) | AWS S3 Trigger / Cron |
    | 로그 파싱 | `re.search(r"ERROR: (.*)", line)` | IF Node (Regex) |
    | 집계/임계치 | `dict` + `datetime` (시간 창 관리) | Code Node (JS) (Static Data 활용) |
    | 알림 | `jira.create_issue(...)` | Jira Node / PagerDuty Node |
  - **실무 활용**:
      - **적용 부서**: SRE팀, DevOps팀
      - **도입 효과**: 유료 로그 분석(ELK, Splunk) 시스템 없이도 핵심 장애 징후를 실시간으로 포착.
      - **확장 아이디어**: 단순 텍스트 매칭이 아닌, 머신러닝(e.g., Isolation Forest)을 이용한 비정상 트래픽 패턴 감지.

────────────────────────────
[고급] 시나리오 19️⃣: **양방향 데이터 동기화 (Google Sheets ↔ Notion DB)**

  - **코드 구현**: Python/JS (gspread, notion\_client, schedule)
  - **주요 단계**: (트리거) 5분 주기 스케줄 실행 → (로직) 구글 시트 데이터 로드 (A) → (로직) 노션 DB 데이터 로드 (B) → (로직) A와 B 비교 (e.g., `last_edited_time` 기준) → (로직) A에서 변경된 것 B에 적용, B에서 변경된 것 A에 적용 → (로직) 무한 루프 방지 (e.g., 'updated\_by\_bot' 플래그)
  - **n8n 구성**: Cron → Google Sheets (Read) + Notion (Search) → Merge Node → Code Node (변경 사항 비교 및 동기화 로직) → Google Sheets (Update) + Notion (Update)
  - **비교표**:
    | 항목 | 코드 (Python/JS) | n8n |
    |---|---|---|
    | 트리거 | `schedule` 라이브러리 (Polling) | Cron Node |
    | 데이터 비교 | `dict`/`list` 순회 및 `last_edited` 비교 | Code Node (JS/Python) |
    | 양방향 업데이트 | `gspread.update(...)` + `notion.pages.update(...)` | Google Sheets (Update) + Notion (Update) |
    | 무한 루프 방지 | 코드 내 플래그 변수/메타데이터 활용 | Code Node 내 로직으로 구현 |
  - **실무 활용**:
      - **적용 부서**: PM, 기획팀 (시트의 편의성과 노션의 DB 기능을 둘 다 사용)
      - **도입 효과**: 두 플랫폼 중 어느 곳에서 수정하든 데이터가 실시간으로 동기화되어 일관성 유지.
      - **확장 아이디어**: (매우 고난도) Webhook 기반으로 실시간 양방향 동기화 구현.

────────────────────────────
[고급] 시나리오 20️⃣: **슬랙 기반 결재 승인 워크플로우**

  - **코드 구현**: Python (Flask/FastAPI + slack\_sdk)
  - **주요 단계**: (트리거) 사용자가 '/휴가신청' Slash Command 입력 → (로직) Modal(팝업) 띄우기 (날짜, 사유 입력) → (로직) Modal 제출 시, 1차 매니저에게 승인/반려 버튼이 포함된 DM 발송 → (로직) 매니저가 버튼 클릭 (Interaction Webhook 수신) → (출력) 승인 시: 캘린더 등록, HR팀 알림 / 반려 시: 신청자에게 반려 사유 알림
  - **n8n 구성**: Slack Trigger (Slash Command) → Slack Node (Modal Open) → Wait Node → Slack Trigger (Interaction) → IF (승인/반려) → [Route 1] Google Calendar + Slack (HR) → [Route 2] Slack (신청자)
  - **비교표**:
    | 항목 | 코드 (Python + FastAPI) | n8n |
    |---|---|---|
    | 트리거 (시작) | `app.post("/slack/command")` | Slack Trigger (Slash Command) |
    | 팝업/버튼 | `client.views_open(...)`<br>`client.chat_postMessage(blocks=...)` | Slack Node (Modal / Send Message) |
    | 응답 대기 | (상태 없음) / Webhook 엔드포인트 분리 | Wait Node (Wait for Webhook) |
    | 트리거 (중간) | `app.post("/slack/interaction")` | Slack Trigger (Interaction) |
  - **실무 활용**:
      - **적용 부서**: 전사 (휴가, 비용, 외근 신청)
      - **도입 효과**: 별도 그룹웨어 없이, 가장 많이 쓰는 메신저(슬랙) 내에서 모든 결재를 신속하게 처리.
      - **확장 아이디어**: 결재 승인 내역을 구글 시트(결재 원장)에 실시간으로 기록.

-----

### [AI 응용] (AI-Applied)

LLM(ChatGPT, Gemini 등) API를 연동하여 단순 자동화를 넘어 지능형 자동화를 구현하는 시나리오.

────────────────────────────
[AI 응용] 시나리오 21️⃣: **고객 문의(CS) 1차 자동 응답 (분류/감성분석)**

  - **코드 구현**: Python (imaplib, openai, requests)
  - **주요 단계**: (트리거) CS 메일 수신 → (로직) OpenAI API 호출 (프롬프트: "이 문의를 요약하고, '환불', '배송', '오류', '기타'로 분류하고, 감성 점수를 1\~10점으로 매겨줘.") → (로직) 분류가 '환불'이고 감성 점수가 3점 이하(매우 부정적)일 경우 → (출력) 즉시 매니저에게 긴급 알림
  - **n8n 구성**: Gmail Trigger → OpenAI / Mistral Node (분류/감성분석) → IF Node (e.g., `sentiment_score <= 3`) → Slack Node (긴급)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `imaplib` 폴링 | Gmail Trigger |
    | AI 분석 | `openai.ChatCompletion.create(...)` | OpenAI Node / Mistral Node |
    | 조건 분기 | `if result['sentiment'] == 'Negative':` | IF Node |
  - **실무 활용**:
      - **적용 부서**: CS팀
      - **도입 효과**: 챗봇 수준을 넘어, 부정적 감정의 고객을 AI가 선별하여 매니저가 우선 대응하도록 지원.
      - **확장 아이디어**: 단순 문의는 AI가 생성한 답변 초안을 담당자에게 전달하여 '보내기'만 누르도록 함.

────────────────────────────
[AI 응용] 시나리오 22️⃣: **회의록(STT) 자동 요약 및 Action Item 추출**

  - **코드 구현**: Python (watchdog, openai)
  - **주요 단계**: (트리거) Zoom 녹화/STT 파일이 특정 폴더(Google Drive)에 생성 완료 시 → (로직) STT 텍스트 파일 읽기 → (로직) OpenAI API 호출 (프롬프트: "다음 회의록을 3줄 요약하고, 주요 안건을 정리하고, Action Item(담당자, 기한)을 표 형식으로 추출해줘.") → (출력) Notion/Confluence 회의록 페이지에 자동 저장
  - **n8n 구성**: Google Drive Trigger (File Created) → Read Binary File → OpenAI Node (요약/추출) → Notion Node (Create Page)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `Google Drive API` (Push/Polling) | Google Drive Trigger |
    | 텍스트 추출 | `open(file, 'r').read()` | Read Binary File → Set Node |
    | AI 요약 | `openai.ChatCompletion.create(prompt=...)` | OpenAI Node (Prompt) |
    | 문서 저장 | `notion_client.pages.create(...)` | Notion Node |
  - **실무 활용**:
      - **적용 부서**: PM, 기획팀 (회의가 많은 부서)
      - **도입 효과**: 1시간짜리 회의 녹화본을 다시 보거나 STT를 읽을 필요 없이, AI가 요약한 핵심만 확인.
      - **확장 아이디어**: Action Item을 Jira/Trello 티켓으로 자동 생성.

────────────────────────────
[AI 응용] 시나리오 23️⃣: **경쟁사 분석 및 블로그 초안 자동 생성**

  - **코드 구현**: Python (feedparser, requests, beautifulsoup4, openai)
  - **주요 단계**: (트리거) 매일 아침 스케줄 실행 → (로직) 경쟁사 블로그 RSS, 업계 뉴스 크롤링 → (로직) 신규 콘텐츠 취합 → (로직) OpenAI API 호출 ("최근 업계 동향과 경쟁사 A, B의 활동을 요약하고, 우리 회사 블로그 포스트 초안을 '전문가 톤'으로 작성해줘.") → (출력) Google Docs / Notion에 초안 저장 및 마케팅팀 알림
  - **n8n 구성**: Cron → RSS Feed (Loop) + HTTP Request (Loop) → Merge → OpenAI Node (초안 작성) → Google Docs / Notion Node → Slack
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 정보 수집 | `feedparser`, `requests` | RSS Feed Node, HTTP Request Node |
    | 정보 취합 | `list.append()` | Merge Node |
    | 초안 생성 | `openai.ChatCompletion.create(prompt=...)` | OpenAI Node |
    | 초안 저장 | `googleapiclient` (Docs) | Google Docs Node / Notion Node |
  - **실무 활용**:
      - **적용 부서**: 콘텐츠 마케팅팀
      - **도입 효과**: 콘텐츠 리서치 및 초안 작성 시간을 80% 이상 단축.
      - **확장 아이디어**: 생성된 초안을 기반으로 DALL-E/Imagen API를 호출하여 블로그 썸네일 이미지까지 자동 생성.

────────────────────────────
[AI 응용] 시나리오 24️⃣: **업로드 이미지 자동 태깅 및 분류 (Vision AI)**

  - **코드 구현**: Python (watchdog, google-cloud-vision)
  - **주요 단계**: (트리거) S3/Google Drive 특정 폴더에 이미지 업로드 감지 → (로직) Google Vision AI API 호출 (Object Detection, Label Detection) → (로직) 반환된 태그(e.g., 'dog', 'park', 'person') 추출 → (출력) 파일 메타데이터(x-amz-meta-tag)에 태그 저장 또는 Notion DB에 이미지 링크와 태그 저장
  - **n8n 구성**: AWS S3 Trigger / Google Drive Trigger → Google Vision Node (Label/Object) → Set Node (태그 가공) → Notion Node / AWS S3 Node (Update Metadata)
  - **비교표**:
    | 항목 | 코드 (Python) | n8n |
    |---|---|---|
    | 트리거 | `S3 Event Notification` (Lambda) | AWS S3 Trigger |
    | 이미지 분석 | `vision.ImageAnnotatorClient()` | Google Vision Node |
    | 메타데이터 저장 | `s3.copy_object(Metadata=...)` | AWS S3 Node (Update) / Notion Node |
  - **실무 활용**:
      - **적용 부서**: 디자인팀, 마케팅팀 (자산 관리)
      - **도입 효과**: 수천 장의 스톡 이미지, 제품 사진 등을 AI가 자동 분류하여 검색 효율성 극대화.
      - **확장 아이디어**: 부적절한(NSFW) 이미지가 업로드될 경우, AI가 자동 감지하여 즉시 격리/알림.

────────────────────────────
[AI 응용] 시나리오 25️⃣: **GitHub 코드 리뷰 자동화 (PR 코멘트)**

  - **코드 구현**: JS (Node.js/Probot) + Python (openai)
  - **주요 단계**: (트리거) GitHub PR(Pull Request) 생성 Webhook 수신 → (로직) PR의 `diff` (변경된 코드) 추출 → (로직) OpenAI API 호출 (프롬프트: "이 코드 변경 사항을 리뷰해줘. 버그 가능성, 성능 저하, 스타일 가이드 위반 여부를 체크하고, 수정 제안을 해줘.") → (출력) GitHub API로 PR에 코멘트 자동 등록
  - **n8n 구성**: GitHub Trigger (PR Opened/Edited) → HTTP Request (Get PR Diff) → OpenAI Node (코드 리뷰) → GitHub Node (Create Comment)
  - **비교표**:
    | 항목 | 코드 (Python/JS) | n8n |
    |---|---|---|
    | 트리거 | `app.on("pull_request.opened", ...)` | GitHub Trigger (Event: `pull_request`) |
    | Diff 추출 | `context.octokit.pulls.get(..., { mediaType: { format: "diff" } })` | HTTP Request (GitHub API, diff 헤더) |
    | AI 리뷰 | `openai.ChatCompletion.create(...)` | OpenAI Node |
    | 코멘트 | `context.octokit.issues.createComment(...)` | GitHub Node (Create Comment) |
  - **실무 활용**:
      - **적용 부서**: 개발팀
      - **도입 효과**: 동료 리뷰어가 미처 발견하지 못한 잠재적 버그를 AI가 1차 스크리닝, 코드 품질 상향 평준화.
      - **확장 아이디어**: AI 리뷰 통과 시 'AI-Approved' 라벨 자동 부착.